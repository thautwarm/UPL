(* almost the vanilla Damas-Hindley-Milner
 type system
 *)
module rec HM

open CamlCompat

(* whether to show the type variable's uniqueness *)
let verbose_printing = ref false

(*
// unique_name
// this is the key point for us
// to avoid checking fresh type
// variables' escapeness
*)

type un
    = { (* to distinguish from variables generated by other runtime *)
        time_ns : int64;
        runtime_id : int;
        name : string
      }

let current_runtime_id_count = ref 0
let current_runtime_time_ns = time_ns()

let un (name: string) =
  { time_ns = current_runtime_time_ns
  ; name = name
  ; runtime_id =
      let i = !current_runtime_id_count in
      let _ = incr current_runtime_id_count in i
  }

let show_un { time_ns = time_ns
            ; runtime_id = runtime_id
            ; name = name
            }
    = if !verbose_printing then
        sprintf "%s@(%u-%u)"  name runtime_id time_ns
      else name

type t =
  (* leaf *)
  | TNom of string
  | TVar of int
  | TBound of un

  | TApp of t * t
  | TArrow of t * t
  | TTup of t list
  | TForall of un list * t

  (* extension from HM *)
  (* for higher rank types, this is not required *)
  (* implicit type is from type class *)
  | TImplicit of t
  with override me.ToString() = HM.show_t me


let top_t =
  let un = un "a" in
  TForall([un], TBound un)

let generic_transform : (t -> t) -> (t -> t)
    = fun self root ->
    (* for ocaml compatibility, we don't use
       active patterns here, though it's a good use case
    *)
    let (!) = self in
    match root with
    | TVar _ | TBound _ | TNom _ -> root
    | TApp(f, arg) -> TApp(!f, !arg)
    | TArrow(from, to') -> TArrow(!from, !to')
    | TTup(xs) -> TTup <| List.map self xs
    | TForall(ns, t) -> TForall(ns, !t)
    | TImplicit t -> TImplicit (!t)


let generic_trans_ctx : ('ctx -> t -> t) -> ('ctx -> t -> t)
    = fun self ctx root ->
    // for ocaml compatibility, we don't use
    // active patterns here, though it's a good use case
    let (!) = self ctx in
    match root with
    | TVar _ | TBound _ | TNom _ -> root
    | TApp(f, arg) -> TApp(!f, !arg)
    | TArrow(from, to') -> TArrow(!from, !to')
    | TTup(xs) -> TTup <| List.map (!) xs
    | TForall(ns, t) -> TForall(ns, !t)
    | TImplicit t -> TImplicit (!t)

let generic_check : (t -> bool) -> (t -> bool)
    = fun self root ->
    let (!) = self in
    match root with
    | TVar _ | TBound _ | TNom _ -> true
    | TApp(f, arg) -> !f && !arg
    | TArrow(from, to') -> !from && !to'
    | TTup(xs) -> List.forall self xs
    | TForall(_, t) -> !t
    | TImplicit t -> !t

let need_parens : t -> bool
    = function
      | TForall(_, _)
      | TApp(_, _)
      | TArrow(_, _) -> true
      | _ -> false



let rec show_t
  = fun x ->
  let nest t =
    let s = show_t t in
    if need_parens t then
      "(" ^ s  ^ ")"
    else s
  in
  let (!) = show_t in
  match x with
  | TVar v -> sprintf "'%d" v
  | TNom s -> s
  | TBound un -> show_un un
  | TApp(f, a) ->
    !f ^ " " ^ nest a
  | TArrow(a, r) ->
    nest a ^ " -> " ^ !r
  | TTup xs ->
    "<" ^ String.concat ", " (List.map show_t xs) ^ ">"
  | TForall(ns, t)  ->
    "forall " ^ String.concat " " (List.map show_un ns)
    ^ "." ^ !t
  | TImplicit t ->
    "{" ^ !t ^ "}"
